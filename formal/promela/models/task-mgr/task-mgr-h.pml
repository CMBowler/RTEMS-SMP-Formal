#define NUM_PROC 5

// We use two semaphores to synchronise the tasks
#define INVALID_ENTRY       (0)
#define SEMA_CREATEDELETE 	(0) // Model Specific Lock
#define SEMA_TASK_START_0 	(1)
#define SEMA_TASK_START_1  	(2)
#define SEMA_LOCK           (3)

/*
 * We need to output annotations for any #define we use.
 * It is simplest to keep them all together,
 * and use an inline to output them.
 */

#define MAX_PRIO 255
#define BAD_PRIO MAX_PRIO
#define CURRENT_PRIO 0
#define LOW_PRIO 1
#define MED_PRIO 5
#define HIGH_PRIO 10

#define INVALID_ID 0
#define RUNNER_ID 1
#define TASK0_ID 2
#define TASK1_ID 3

#define CLEAR_TASKS 255
byte task_control = CLEAR_TASKS;

inline outputDefines () {

	printf("@@@ %d DEF TASK_MAX %d\n",_pid,TASK_MAX);
	printf("@@@ %d DEF INVALID_ID %d\n",_pid,INVALID_ID);
	printf("@@@ %d DEF SEMA_MAX %d\n",_pid,SEMA_MAX);

    // Priority inversion
    printf("@@@ %d DEF LOW_PRIO %d\n",_pid,HIGH_PRIO);
    printf("@@@ %d DEF MED_PRIO %d\n",_pid,MED_PRIO);
    printf("@@@ %d DEF HIGH_PRIO %d\n",_pid,LOW_PRIO);
	
	printf("@@@ %d DEF RC_OK RTEMS_SUCCESSFUL\n",_pid);
	printf("@@@ %d DEF RC_InvId RTEMS_INVALID_ID\n",_pid);
	printf("@@@ %d DEF RC_InvAddr RTEMS_INVALID_ADDRESS\n",_pid);
	printf("@@@ %d DEF RC_Unsat RTEMS_UNSATISFIED\n",_pid);
	printf("@@@ %d DEF RC_Timeout RTEMS_TIMEOUT\n",_pid);
}

inline outputDeclarations () {
  printf("@@@ %d DECL byte createRC 0\n",_pid);
  printf("@@@ %d DECL byte startRC 0\n",_pid);
  printf("@@@ %d DECL byte deleteRC 0\n",_pid);
  printf("@@@ %d DECL byte suspendRC 0\n",_pid);
  printf("@@@ %d DECL byte isSuspendRC 0\n",_pid);
  printf("@@@ %d DECL byte resumeRC 0\n",_pid);
  printf("@@@ %d DECL byte setPriorityRC 0\n",_pid);
  // Rather than refine an entire Task array, we refine array 'slices'
  //printf("@@@ %d DCLARRAY EvtSet pending TASK_MAX\n",_pid);
  //printf("@@@ %d DCLARRAY byte recout TASK_MAX\n",_pid);
  printf("@@@ %d DCLARRAY byte taskID TASK_MAX\n", _pid);
  printf("@@@ %d DCLARRAY Task tasks TASK_MAX\n",_pid);
  printf("@@@ %d DCLARRAY Semaphore semaphore SEMA_MAX\n",_pid);
}

typedef Mode {
    bool preempt;
    bool timeslice;
    bool ASR;
    int isr_lvl;
}

inline ObtainMutex(tid, sid) {
    TestSyncObtain(sid);
    tasks[tid].mutexs[sid] = 1;
}

inline ReleaseMutex(tid, sid) { 
    if
    ::  tasks[tid].mutexs[sid] == 1 ->
            TestSyncRelease(sid);
            //rc = true;
    ::  else //-> rc = false
    fi
}

inline isNameValid(name, rc) {
    if
    ::  name == 0 ->
            rc = false;
    ::  else -> 
            rc = true;
    fi
}

inline setTask(tid, rc) {
    byte raw_tid;
    //TestSyncObtain(SEMA_TASKCONTROL);
    raw_tid = task_control & (~task_control + 1);
    task_control = task_control - raw_tid;
    //TestSyncRelease(SEMA_TASKCONTROL);
    rc = true;
    if
    ::  raw_tid == 2 ->
            tid = 1;
    ::  raw_tid == 4 ->
            tid = 2;
    ::  raw_tid == 8 ->
            tid = 3;
    ::  raw_tid == 16 ->
            tid = 4;
/*    
	::  raw_tid == 32 ->
            tid = 5;
    ::  raw_tid == 64 ->
            tid = 6;
    ::  raw_tid == 128 ->
            tid = 7;
*/
    ::  else ->
            tid = 1;
            rc = false;
    fi
}

inline removeTask(tid, rc) {
    byte raw_tid = 1 << tid;
    //TestSyncObtain(SEMA_TASKCONTROL);
    if
    ::  (task_control & raw_tid) != raw_tid ->
            task_control = task_control + raw_tid;
            rc = true;
    ::  (task_control & raw_tid) == raw_tid ->
            rc = false;
    fi
    //TestSyncRelease(SEMA_TASKCONTROL);
}