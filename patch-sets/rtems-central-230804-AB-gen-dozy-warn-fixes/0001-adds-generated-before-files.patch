From e6a6b952277993e42613dc50dd72d40e6d8f296a Mon Sep 17 00:00:00 2001
From: Andrew Butterfield <andrew.butterfield@scss.tcd.ie>
Date: Fri, 4 Aug 2023 14:36:52 +0100
Subject: [PATCH 01/10] adds generated before files

---
 .../before-fix/tr-chains-api-model-0.c        | 170 ++++++++
 .../before-fix/tr-chains-api-model-1.c        | 172 ++++++++
 .../before-fix/tr-chains-api-model-10.c       | 172 ++++++++
 .../before-fix/tr-chains-api-model-11.c       | 172 ++++++++
 .../before-fix/tr-chains-api-model-12.c       | 174 ++++++++
 .../before-fix/tr-chains-api-model-13.c       | 172 ++++++++
 .../before-fix/tr-chains-api-model-14.c       | 174 ++++++++
 .../before-fix/tr-chains-api-model-15.c       | 172 ++++++++
 .../before-fix/tr-chains-api-model-16.c       | 172 ++++++++
 .../before-fix/tr-chains-api-model-17.c       | 172 ++++++++
 .../before-fix/tr-chains-api-model-18.c       | 174 ++++++++
 .../before-fix/tr-chains-api-model-19.c       | 172 ++++++++
 .../before-fix/tr-chains-api-model-2.c        | 170 ++++++++
 .../before-fix/tr-chains-api-model-20.c       | 174 ++++++++
 .../before-fix/tr-chains-api-model-3.c        | 172 ++++++++
 .../before-fix/tr-chains-api-model-4.c        | 172 ++++++++
 .../before-fix/tr-chains-api-model-5.c        | 174 ++++++++
 .../before-fix/tr-chains-api-model-6.c        | 172 ++++++++
 .../before-fix/tr-chains-api-model-7.c        | 174 ++++++++
 .../before-fix/tr-chains-api-model-8.c        | 172 ++++++++
 .../before-fix/tr-chains-api-model-9.c        | 170 ++++++++
 .../before-fix/tr-event-mgr-model-0.c         | 347 ++++++++++++++++
 .../before-fix/tr-event-mgr-model-1.c         | 345 ++++++++++++++++
 .../before-fix/tr-event-mgr-model-10.c        | 378 +++++++++++++++++
 .../before-fix/tr-event-mgr-model-2.c         | 358 ++++++++++++++++
 .../before-fix/tr-event-mgr-model-3.c         | 343 +++++++++++++++
 .../before-fix/tr-event-mgr-model-4.c         | 364 ++++++++++++++++
 .../before-fix/tr-event-mgr-model-5.c         | 364 ++++++++++++++++
 .../before-fix/tr-event-mgr-model-6.c         | 364 ++++++++++++++++
 .../before-fix/tr-event-mgr-model-7.c         | 364 ++++++++++++++++
 .../before-fix/tr-event-mgr-model-8.c         | 386 +++++++++++++++++
 .../before-fix/tr-event-mgr-model-9.c         | 391 ++++++++++++++++++
 32 files changed, 7622 insertions(+)
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-0.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-1.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-10.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-11.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-12.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-13.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-14.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-15.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-16.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-17.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-18.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-19.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-2.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-20.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-3.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-4.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-5.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-6.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-7.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-8.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-9.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-0.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-1.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-10.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-2.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-3.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-4.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-5.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-6.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-7.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-8.c
 create mode 100644 formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-9.c

diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-0.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-0.c
new file mode 100644
index 00000000..5e5d83b5
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-0.c
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run0(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI0 )
+{
+  RtemsModelChainsAPI_Run0( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-1.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-1.c
new file mode 100644
index 00000000..a8774234
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-1.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run1(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI1 )
+{
+  RtemsModelChainsAPI_Run1( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-10.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-10.c
new file mode 100644
index 00000000..4e960621
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-10.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run10(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI10 )
+{
+  RtemsModelChainsAPI_Run10( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-11.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-11.c
new file mode 100644
index 00000000..064fcf44
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-11.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run11(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI11 )
+{
+  RtemsModelChainsAPI_Run11( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-12.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-12.c
new file mode 100644
index 00000000..1d8f8609
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-12.c
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run12(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI12 )
+{
+  RtemsModelChainsAPI_Run12( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-13.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-13.c
new file mode 100644
index 00000000..09392672
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-13.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run13(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI13 )
+{
+  RtemsModelChainsAPI_Run13( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-14.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-14.c
new file mode 100644
index 00000000..9ea65d25
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-14.c
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run14(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI14 )
+{
+  RtemsModelChainsAPI_Run14( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-15.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-15.c
new file mode 100644
index 00000000..38844092
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-15.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run15(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI15 )
+{
+  RtemsModelChainsAPI_Run15( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-16.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-16.c
new file mode 100644
index 00000000..36d9833a
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-16.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run16(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI16 )
+{
+  RtemsModelChainsAPI_Run16( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-17.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-17.c
new file mode 100644
index 00000000..1042b363
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-17.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run17(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI17 )
+{
+  RtemsModelChainsAPI_Run17( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-18.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-18.c
new file mode 100644
index 00000000..b6c4d21a
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-18.c
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run18(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI18 )
+{
+  RtemsModelChainsAPI_Run18( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-19.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-19.c
new file mode 100644
index 00000000..c8e65fbe
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-19.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run19(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI19 )
+{
+  RtemsModelChainsAPI_Run19( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-2.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-2.c
new file mode 100644
index 00000000..5ad885ab
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-2.c
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run2(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI2 )
+{
+  RtemsModelChainsAPI_Run2( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-20.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-20.c
new file mode 100644
index 00000000..40dec01c
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-20.c
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run20(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI20 )
+{
+  RtemsModelChainsAPI_Run20( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-3.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-3.c
new file mode 100644
index 00000000..54193f5f
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-3.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run3(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI3 )
+{
+  RtemsModelChainsAPI_Run3( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-4.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-4.c
new file mode 100644
index 00000000..8353ac02
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-4.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run4(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI4 )
+{
+  RtemsModelChainsAPI_Run4( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-5.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-5.c
new file mode 100644
index 00000000..a52176dd
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-5.c
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run5(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI5 )
+{
+  RtemsModelChainsAPI_Run5( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-6.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-6.c
new file mode 100644
index 00000000..ff617210
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-6.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run6(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI6 )
+{
+  RtemsModelChainsAPI_Run6( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-7.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-7.c
new file mode 100644
index 00000000..c51a7865
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-7.c
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run7(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI7 )
+{
+  RtemsModelChainsAPI_Run7( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-8.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-8.c
new file mode 100644
index 00000000..b7c455d7
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-8.c
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run8(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI8 )
+{
+  RtemsModelChainsAPI_Run8( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-9.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-9.c
new file mode 100644
index 00000000..0b7993b5
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-chains-api-model-9.c
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/******************************************************************************
+ * Chains API Model
+ *
+ * Copyright (C) 2019-2021 Trinity College Dublin (www.tcd.ie)
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *
+ *     * Neither the name of the copyright holders nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+
+#include <rtems.h>
+#include <rtems/test.h>
+#include <rtems/chain.h>
+#include "tr-chains-api-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Chain_AutoGen
+// @@@ 0 DEF MAX_SIZE 8
+#define MAX_SIZE 8
+// @@@ 0 DCLARRAY Node memory MAX_SIZE
+static item memory[MAX_SIZE];
+// @@@ 0 DECL unsigned nptr NULL
+static item * nptr = NULL;
+// @@@ 0 DECL Control chain
+static rtems_chain_control chain;
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  const char rtems_test_name[] = "Model_Chain_API";
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  rtems_chain_initialize_empty( &chain );
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 0");
+  T_eq_ptr( nptr, NULL );
+  T_log(T_NORMAL,"@@@ 0 CALL append 22 3");
+  memory[3].val = 22;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 22");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 22 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 3");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[3] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 3");
+  T_eq_ptr( nptr, &memory[3] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 22");
+  T_eq_int( nptr->val, 22 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 21 6");
+  memory[6].val = 21;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 21");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 21 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 6");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[6] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 6");
+  T_eq_ptr( nptr, &memory[6] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 21");
+  T_eq_int( nptr->val, 21 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+  T_log(T_NORMAL,"@@@ 0 CALL append 23 4");
+  memory[4].val = 23;
+  rtems_chain_append_unprotected( &chain, (rtems_chain_node*)&memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 SCALAR _ 23");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 23 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 CALL getNonNull 4");
+  nptr = get_item( &chain );
+  T_eq_ptr( nptr, &memory[4] );
+  
+  T_log(T_NORMAL,"@@@ 0 SEQ chain");
+  T_log(T_NORMAL,"@@@ 0 END chain");
+  show_chain( &chain, ctx->buffer );
+  T_eq_str( ctx->buffer, " 0" );
+  
+  T_log(T_NORMAL,"@@@ 0 PTR nptr 4");
+  T_eq_ptr( nptr, &memory[4] );
+  T_log(T_NORMAL,"@@@ 0 STRUCT nptr");
+  T_log(T_NORMAL,"@@@ 0 SCALAR itm 23");
+  T_eq_int( nptr->val, 23 );
+  T_log(T_NORMAL,"@@@ 0 END nptr");
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+/* post-amble empty for now */
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+void RtemsModelChainsAPI_Run9(
+)
+{
+  Context ctx;
+
+  memset( &ctx, 0, sizeof( ctx ) );
+
+  T_set_verbosity( T_NORMAL );
+
+  TestSegment0( &ctx );
+}
+
+T_TEST_CASE( RtemsModelChainAPI9 )
+{
+  RtemsModelChainsAPI_Run9( );
+}
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-0.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-0.c
new file mode 100644
index 00000000..7fcfd63d
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-0.c
@@ -0,0 +1,347 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 3 10 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 3), 10 );
+  sendrc = ( *ctx->send )( mapid( ctx, 3 ), 10 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckNoPreemption");
+  log = &ctx->thread_switch_log;
+  T_le_sz( log->header.recorded, 1 );
+  for ( size_t i = 0; i < log->header.recorded; ++i ) {
+    T_ne_u32( log->events[ i ].executing, ctx->worker_id );
+    T_eq_u32( log->events[ i ].heir, ctx->runner_id );
+  }
+  
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 4");
+  T_rsc( sendrc, 4 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker0( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage0[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig0 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage0,
+  .storage_size = sizeof( WorkerStorage0 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup0(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig0, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker0, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap0( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup0( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance0;
+
+static T_fixture RtemsModelEventsMgr_Fixture0 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap0,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance0
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node0;
+
+void RtemsModelEventsMgr_Run0(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node0,
+    &RtemsModelEventsMgr_Fixture0
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 0;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-1.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-1.c
new file mode 100644
index 00000000..d042d792
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-1.c
@@ -0,0 +1,345 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 0 1 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 0, 1 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 0, 1 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 13");
+  T_rsc( recrc, 13 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 0");
+  T_eq_int( recout[2], 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker1( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage1[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig1 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage1,
+  .storage_size = sizeof( WorkerStorage1 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup1(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig1, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker1, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap1( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup1( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance1;
+
+static T_fixture RtemsModelEventsMgr_Fixture1 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap1,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance1
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node1;
+
+void RtemsModelEventsMgr_Run1(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node1,
+    &RtemsModelEventsMgr_Fixture1
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 1;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-10.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-10.c
new file mode 100644
index 00000000..2b1ba123
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-10.c
@@ -0,0 +1,378 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL SetProcessor 1");
+  T_ge_u32( rtems_scheduler_get_processor_maximum(), 2 );
+  uint32_t processor = 1;
+  cpu_set_t cpuset;
+  CPU_ZERO(&cpuset);
+  CPU_SET(processor, &cpuset);
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 10 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 10 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 10 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckNoPreemption");
+  log = &ctx->thread_switch_log;
+  T_le_sz( log->header.recorded, 1 );
+  for ( size_t i = 0; i < log->header.recorded; ++i ) {
+    T_ne_u32( log->events[ i ].executing, ctx->worker_id );
+    T_eq_u32( log->events[ i ].heir, ctx->runner_id );
+  }
+  
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL SetProcessor 0");
+  T_ge_u32( rtems_scheduler_get_processor_maximum(), 2 );
+  uint32_t processor = 0;
+  cpu_set_t cpuset;
+  CPU_ZERO(&cpuset);
+  CPU_SET(processor, &cpuset);
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 10");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 10 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 1 1 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 1, 1 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 1, 1 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 0");
+  T_rsc( recrc, 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 10");
+  T_eq_int( recout[2], 10 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker10( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage10[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig10 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage10,
+  .storage_size = sizeof( WorkerStorage10 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup10(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig10, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker10, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap10( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup10( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance10;
+
+static T_fixture RtemsModelEventsMgr_Fixture10 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap10,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance10
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node10;
+
+void RtemsModelEventsMgr_Run10(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node10,
+    &RtemsModelEventsMgr_Fixture10
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 10;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-2.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-2.c
new file mode 100644
index 00000000..2a70b8d1
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-2.c
@@ -0,0 +1,358 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 2 =====
+
+static void TestSegment2( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 2 STATE 2 Ready");
+  /* We (Task 2) must have been recently ready because we are running */
+
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 1 1 4 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 1, 1 ) ,4 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 1, 1 ), 4, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 TimeWait 4");
+  //  DON'T KNOW HOW TO REFINE: 4 'STATE
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Ready");
+  /* We (Task 2) must have been recently ready because we are running */
+
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 6");
+  T_rsc( recrc, 6 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 0");
+  T_eq_int( recout[2], 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker2( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage2[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig2 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage2,
+  .storage_size = sizeof( WorkerStorage2 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup2(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig2, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker2, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap2( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup2( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance2;
+
+static T_fixture RtemsModelEventsMgr_Fixture2 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap2,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance2
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node2;
+
+void RtemsModelEventsMgr_Run2(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node2,
+    &RtemsModelEventsMgr_Fixture2
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 2;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-3.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-3.c
new file mode 100644
index 00000000..c0437dd4
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-3.c
@@ -0,0 +1,343 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 1 1 0 0 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 1, 1 ) ,0 , 0 ? &recout[0] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 1, 1 ), 0, 0 ? &recout[0] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 9");
+  T_rsc( recrc, 9 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker3( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage3[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig3 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage3,
+  .storage_size = sizeof( WorkerStorage3 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup3(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig3, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker3, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap3( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup3( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance3;
+
+static T_fixture RtemsModelEventsMgr_Fixture3 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap3,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance3
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node3;
+
+void RtemsModelEventsMgr_Run3(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node3,
+    &RtemsModelEventsMgr_Fixture3
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 3;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-4.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-4.c
new file mode 100644
index 00000000..eefb0fdc
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-4.c
@@ -0,0 +1,364 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 14 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 14 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 14 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckNoPreemption");
+  log = &ctx->thread_switch_log;
+  T_le_sz( log->header.recorded, 1 );
+  for ( size_t i = 0; i < log->header.recorded; ++i ) {
+    T_ne_u32( log->events[ i ].executing, ctx->worker_id );
+    T_eq_u32( log->events[ i ].heir, ctx->runner_id );
+  }
+  
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 14");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 14 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 1 1 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 1, 1 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 1, 1 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 0");
+  T_rsc( recrc, 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 10");
+  T_eq_int( recout[2], 10 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 4");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 4 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker4( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage4[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig4 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage4,
+  .storage_size = sizeof( WorkerStorage4 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup4(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig4, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker4, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap4( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup4( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance4;
+
+static T_fixture RtemsModelEventsMgr_Fixture4 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap4,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance4
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node4;
+
+void RtemsModelEventsMgr_Run4(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node4,
+    &RtemsModelEventsMgr_Fixture4
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 4;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-5.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-5.c
new file mode 100644
index 00000000..d1d9be55
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-5.c
@@ -0,0 +1,364 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 11 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 11 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 11 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckNoPreemption");
+  log = &ctx->thread_switch_log;
+  T_le_sz( log->header.recorded, 1 );
+  for ( size_t i = 0; i < log->header.recorded; ++i ) {
+    T_ne_u32( log->events[ i ].executing, ctx->worker_id );
+    T_eq_u32( log->events[ i ].heir, ctx->runner_id );
+  }
+  
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 11");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 11 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 1 1 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 1, 1 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 1, 1 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 0");
+  T_rsc( recrc, 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 10");
+  T_eq_int( recout[2], 10 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 1");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 1 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker5( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage5[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig5 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage5,
+  .storage_size = sizeof( WorkerStorage5 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup5(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig5, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker5, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap5( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup5( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance5;
+
+static T_fixture RtemsModelEventsMgr_Fixture5 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap5,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance5
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node5;
+
+void RtemsModelEventsMgr_Run5(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node5,
+    &RtemsModelEventsMgr_Fixture5
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 5;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-6.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-6.c
new file mode 100644
index 00000000..2d3fcd2b
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-6.c
@@ -0,0 +1,364 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 10 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 10 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 10 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckNoPreemption");
+  log = &ctx->thread_switch_log;
+  T_le_sz( log->header.recorded, 1 );
+  for ( size_t i = 0; i < log->header.recorded; ++i ) {
+    T_ne_u32( log->events[ i ].executing, ctx->worker_id );
+    T_eq_u32( log->events[ i ].heir, ctx->runner_id );
+  }
+  
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 10");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 10 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 0 1 1 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 0, mergeopts( 1, 1 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 0, mergeopts( 1, 1 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 0");
+  T_rsc( recrc, 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 10");
+  T_eq_int( recout[2], 10 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 10");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 10 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker6( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage6[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig6 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage6,
+  .storage_size = sizeof( WorkerStorage6 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup6(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig6, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker6, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap6( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup6( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance6;
+
+static T_fixture RtemsModelEventsMgr_Fixture6 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap6,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance6
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node6;
+
+void RtemsModelEventsMgr_Run6(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node6,
+    &RtemsModelEventsMgr_Fixture6
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 6;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-7.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-7.c
new file mode 100644
index 00000000..baa3d854
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-7.c
@@ -0,0 +1,364 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 10 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 10 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 10 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckNoPreemption");
+  log = &ctx->thread_switch_log;
+  T_le_sz( log->header.recorded, 1 );
+  for ( size_t i = 0; i < log->header.recorded; ++i ) {
+    T_ne_u32( log->events[ i ].executing, ctx->worker_id );
+    T_eq_u32( log->events[ i ].heir, ctx->runner_id );
+  }
+  
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 10");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 10 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 15 0 0 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 15, mergeopts( 0, 0 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 15, mergeopts( 0, 0 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 0");
+  T_rsc( recrc, 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 10");
+  T_eq_int( recout[2], 10 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker7( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage7[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig7 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage7,
+  .storage_size = sizeof( WorkerStorage7 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup7(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig7, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker7, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap7( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup7( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance7;
+
+static T_fixture RtemsModelEventsMgr_Fixture7 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap7,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance7
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node7;
+
+void RtemsModelEventsMgr_Run7(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node7,
+    &RtemsModelEventsMgr_Fixture7
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 7;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-8.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-8.c
new file mode 100644
index 00000000..fdec1642
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-8.c
@@ -0,0 +1,386 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 1 =====
+
+static void TestSegment1( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 1 STATE 1 Ready");
+  /* We (Task 1) must have been recently ready because we are running */
+
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL LowerPriority");
+  SetSelfPriority( PRIO_LOW );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_LOW );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 10 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 10 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 10 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckPreemption");
+  log = &ctx->thread_switch_log;
+  T_eq_sz( log->header.recorded, 2 );
+  T_eq_u32( log->events[ 0 ].heir, ctx->runner_id );
+  T_eq_u32( log->events[ 1 ].heir, ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 2 Ready");
+  /* We (Task 2) must have been recently ready because we are running */
+
+  T_log(T_NORMAL,"@@@ 3 STATE 1 OtherWait");
+  /* Code to check that Task 1 is waiting (after pre-emption) */
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Ready");
+  /* We (Task 1) must have been recently ready because we are running */
+
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 1 1 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 1, 1 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 1, 1 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 EventWait");
+  /* Code to check that Task 2 is waiting on events */
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Ready");
+  /* We (Task 2) must have been recently ready because we are running */
+
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 0");
+  T_rsc( recrc, 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 10");
+  T_eq_int( recout[2], 10 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker8( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage8[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig8 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage8,
+  .storage_size = sizeof( WorkerStorage8 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup8(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig8, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker8, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap8( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup8( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance8;
+
+static T_fixture RtemsModelEventsMgr_Fixture8 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap8,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance8
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node8;
+
+void RtemsModelEventsMgr_Run8(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node8,
+    &RtemsModelEventsMgr_Fixture8
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 8;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
diff --git a/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-9.c b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-9.c
new file mode 100644
index 00000000..42815829
--- /dev/null
+++ b/formal/promela/models/issues/sh-23-07-20/before-fix/tr-event-mgr-model-9.c
@@ -0,0 +1,391 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+/**
+ * @file
+ *
+ * @ingroup RTEMSTestCaseRtemsModelEventsMgr
+ */
+
+/*
+ * Copyright (C) 2020 embedded brains GmbH (http://www.embedded-brains.de)
+ *                    Trinity College Dublin (http://www.tcd.ie)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * This file was automatically generated.  Do not edit it manually.
+ * Please have a look at
+ *
+ * https://docs.rtems.org/branches/master/eng/req/howto.html
+ *
+ * for information how to maintain and re-generate this file.
+ */
+
+#ifndef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/score/threadimpl.h>
+
+
+#include "tr-event-mgr-model.h"
+
+//  ===============================================
+
+// @@@ 0 NAME Event_Manager_TestGen
+// @@@ 0 DEF NO_OF_EVENTS 4
+#define NO_OF_EVENTS 4
+// @@@ 0 DEF EVTS_NONE 0
+#define EVTS_NONE 0
+// @@@ 0 DEF EVTS_PENDING 0
+#define EVTS_PENDING 0
+// @@@ 0 DEF EVT_0 1
+#define EVT_0 1
+// @@@ 0 DEF EVT_1 2
+#define EVT_1 2
+// @@@ 0 DEF EVT_2 4
+#define EVT_2 4
+// @@@ 0 DEF EVT_3 8
+#define EVT_3 8
+// @@@ 0 DEF EVTS_ALL 15
+#define EVTS_ALL 15
+// @@@ 0 DEF NO_TIMEOUT 0
+#define NO_TIMEOUT 0
+// @@@ 0 DEF TASK_MAX 3
+#define TASK_MAX 3
+// @@@ 0 DEF BAD_ID 3
+#define BAD_ID 3
+// @@@ 0 DEF SEMA_MAX 2
+#define SEMA_MAX 2
+// @@@ 0 DEF RC_OK RTEMS_SUCCESSFUL
+#define RC_OK RTEMS_SUCCESSFUL
+// @@@ 0 DEF RC_InvId RTEMS_INVALID_ID
+#define RC_InvId RTEMS_INVALID_ID
+// @@@ 0 DEF RC_InvAddr RTEMS_INVALID_ADDRESS
+#define RC_InvAddr RTEMS_INVALID_ADDRESS
+// @@@ 0 DEF RC_Unsat RTEMS_UNSATISFIED
+#define RC_Unsat RTEMS_UNSATISFIED
+// @@@ 0 DEF RC_Timeout RTEMS_TIMEOUT
+#define RC_Timeout RTEMS_TIMEOUT
+// @@@ 0 DECL byte sendrc 0
+static rtems_status_code sendrc = 0;
+// @@@ 0 DECL byte recrc 0
+static rtems_status_code recrc = 0;
+// @@@ 0 DCLARRAY EvtSet pending TASK_MAX
+static rtems_event_set pending[TASK_MAX];
+// @@@ 0 DCLARRAY byte recout TASK_MAX
+static rtems_event_set recout[TASK_MAX];
+// @@@ 0 DCLARRAY Semaphore semaphore SEMA_MAX
+static rtems_id semaphore[SEMA_MAX];
+
+//  ===== TEST CODE SEGMENT 0 =====
+
+static void TestSegment0( Context* ctx ) {
+  /* Test Name is defined in the Test Case code (tc-model-events-mgr.c) */
+  
+  T_log(T_NORMAL,"@@@ 0 INIT");
+  initialise_pending( pending, TASK_MAX );
+  initialise_semaphore( ctx, semaphore );
+  
+}
+
+//  ===== TEST CODE SEGMENT 3 =====
+
+static void TestSegment3( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 3 TASK Worker");
+  checkTaskIs( ctx->worker_id );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL EqualPriority");
+  SetSelfPriority( PRIO_NORMAL );
+  rtems_task_priority prio;
+  rtems_status_code sc;
+  sc = rtems_task_set_priority( RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_NORMAL );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL StartLog");
+  T_thread_switch_log *log;
+  log = T_thread_switch_record_4( &ctx->thread_switch_log );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 2 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 2 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 2 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL CheckNoPreemption");
+  log = &ctx->thread_switch_log;
+  T_le_sz( log->header.recorded, 1 );
+  for ( size_t i = 0; i < log->header.recorded; ++i ) {
+    T_ne_u32( log->events[ i ].executing, ctx->worker_id );
+    T_eq_u32( log->events[ i ].heir, ctx->runner_id );
+  }
+  
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 WAIT 0");
+  Wait( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 3 CALL event_send 1 2 8 sendrc");
+  T_log( T_NORMAL, "Calling Send(%d,%d)", mapid( ctx, 2), 8 );
+  sendrc = ( *ctx->send )( mapid( ctx, 2 ), 8 );
+  T_log( T_NORMAL, "Returned 0x%x from Send", sendrc );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 2 Ready");
+  /* We (Task 2) must have been recently ready because we are running */
+
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Ready");
+  /* We (Task 1) must have been recently ready because we are running */
+
+  T_log(T_NORMAL,"@@@ 3 SCALAR sendrc 0");
+  T_rsc( sendrc, 0 );
+  T_log(T_NORMAL,"@@@ 3 SIGNAL 1");
+  Wakeup( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 3 STATE 1 Zombie");
+  /* Code to check that Task 1 has terminated */
+}
+
+//  ===== TEST CODE SEGMENT 4 =====
+
+static void TestSegment4( Context* ctx ) {
+  T_log(T_NORMAL,"@@@ 4 TASK Runner");
+  checkTaskIs( ctx->runner_id );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 WAIT 1");
+  Wait( semaphore[1] );
+  
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 2");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 2 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 CALL event_receive 10 1 1 0 2 recrc");
+  T_log( T_NORMAL, "Calling Receive(%d,%d,%d,%d)", 10, mergeopts( 1, 1 ) ,0 , 2 ? &recout[2] : NULL );
+  recrc = ( *ctx->receive )( 10, mergeopts( 1, 1 ), 0, 2 ? &recout[2] : NULL );
+  T_log( T_NORMAL, "Returned 0x%x from Receive", recrc );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 EventWait");
+  /* Code to check that Task 2 is waiting on events */
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Ready");
+  /* We (Task 2) must have been recently ready because we are running */
+
+  T_log(T_NORMAL,"@@@ 4 SCALAR recrc 0");
+  T_rsc( recrc, 0 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR recout 2 10");
+  T_eq_int( recout[2], 10 );
+  T_log(T_NORMAL,"@@@ 4 SCALAR pending 2 0");
+  pending[2] = GetPending( ctx );
+  T_eq_int( pending[2], 0 );
+  
+  T_log(T_NORMAL,"@@@ 4 SIGNAL 0");
+  Wakeup( semaphore[0] );
+  
+  T_log(T_NORMAL,"@@@ 4 STATE 2 Zombie");
+  /* Code to check that Task 2 has terminated */
+}
+
+//  ===============================================
+
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Runner( RtemsModelEventsMgr_Context *ctx )
+{
+  T_log( T_NORMAL, "Runner running" );
+  TestSegment4( ctx );
+  T_log( T_NORMAL, "Runner finished" );
+}
+/* SPDX-License-Identifier: BSD-2-Clause */
+
+static void Worker9( rtems_task_argument arg )
+{
+  Context *ctx;
+  rtems_event_set events;
+
+  ctx = (Context *) arg;
+
+  T_log( T_NORMAL, "Worker Running" );
+  TestSegment3( ctx );
+  T_log( T_NORMAL, "Worker finished" );
+
+  // (void) rtems_task_suspend( RTEMS_SELF );
+  // Ensure we hold no semaphores
+  Wakeup( ctx->worker_wakeup );
+  Wakeup( ctx->runner_wakeup );
+  // Wait for events so we don't terminate
+  rtems_event_receive( RTEMS_ALL_EVENTS, RTEMS_DEFAULT_OPTIONS, 0, &events );
+
+}
+
+RTEMS_ALIGNED( RTEMS_TASK_STORAGE_ALIGNMENT ) static char WorkerStorage9[
+  RTEMS_TASK_STORAGE_SIZE(
+    MAX_TLS_SIZE + TEST_MINIMUM_STACK_SIZE,
+    WORKER_ATTRIBUTES
+  )
+];
+
+static const rtems_task_config WorkerConfig9 = {
+  .name = rtems_build_name( 'W', 'O', 'R', 'K' ),
+  .initial_priority = PRIO_LOW,
+  .storage_area = WorkerStorage9,
+  .storage_size = sizeof( WorkerStorage9 ),
+  .maximum_thread_local_storage_size = MAX_TLS_SIZE,
+  .initial_modes = RTEMS_DEFAULT_MODES,
+  .attributes = WORKER_ATTRIBUTES
+};
+
+
+static void RtemsModelEventsMgr_Setup9(
+  RtemsModelEventsMgr_Context *ctx
+)
+{
+  rtems_status_code   sc;
+  rtems_task_priority prio;
+
+  T_log( T_NORMAL, "Runner Setup" );
+
+  memset( ctx, 0, sizeof( *ctx ) );
+  ctx->runner_thread = _Thread_Get_executing();
+  ctx->runner_id = ctx->runner_thread->Object.id;
+
+  T_log( T_NORMAL, "Creating Worker Wakeup Semaphore" );
+  ctx->worker_wakeup = CreateWakeupSema();
+  T_log( T_NORMAL, "Creating Runner Wakeup Semaphore" );
+  ctx->runner_wakeup = CreateWakeupSema();
+
+  sc = rtems_task_get_scheduler( RTEMS_SELF, &ctx->runner_sched );
+  T_rsc_success( sc );
+
+  #if defined(RTEMS_SMP)
+  sc = rtems_scheduler_ident_by_processor( 1, &ctx->other_sched );
+  T_rsc_success( sc );
+  T_ne_u32( ctx->runner_sched, ctx->other_sched );
+  #endif
+
+  prio = 0;
+  sc = rtems_task_set_priority( RTEMS_SELF, PRIO_NORMAL, &prio );
+  T_rsc_success( sc );
+  T_eq_u32( prio, PRIO_HIGH );
+
+  sc = rtems_task_construct( &WorkerConfig9, &ctx->worker_id );
+  T_log( T_NORMAL, "Construct Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+
+  T_log( T_NORMAL, "Starting Worker..." );
+  sc = rtems_task_start( ctx->worker_id, Worker9, (rtems_task_argument) ctx );
+  T_log( T_NORMAL, "Started Worker, sc = %x", sc );
+  T_assert_rsc_success( sc );
+}
+
+
+static void RtemsModelEventsMgr_Setup_Wrap9( void *arg )
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  ctx = arg;
+  RtemsModelEventsMgr_Setup9( ctx );
+}
+
+
+static RtemsModelEventsMgr_Context RtemsModelEventsMgr_Instance9;
+
+static T_fixture RtemsModelEventsMgr_Fixture9 = {
+  .setup = RtemsModelEventsMgr_Setup_Wrap9,
+  .stop = NULL,
+  .teardown = RtemsModelEventsMgr_Teardown_Wrap,
+  .scope = RtemsModelEventsMgr_Scope,
+  .initial_context = &RtemsModelEventsMgr_Instance9
+};
+
+static T_fixture_node RtemsModelEventsMgr_Node9;
+
+void RtemsModelEventsMgr_Run9(
+  rtems_status_code ( *send )( rtems_id, rtems_event_set ),
+  rtems_status_code ( *receive )( rtems_event_set, rtems_option, rtems_interval, rtems_event_set * ),
+  rtems_event_set (   *get_pending_events )( Thread_Control * ),
+  unsigned int         wait_class,
+  int                  waiting_for_event
+)
+{
+  RtemsModelEventsMgr_Context *ctx;
+
+  T_set_verbosity( T_NORMAL );
+
+  T_log( T_NORMAL, "Runner Invoked" );
+  T_log( T_NORMAL, "Runner Wait Class: %d", wait_class );
+  T_log( T_NORMAL, "Runner WaitForEvent: %d", waiting_for_event );
+
+  T_log( T_NORMAL, "Pushing Test Fixture..." );
+
+
+  ctx = T_push_fixture(
+    &RtemsModelEventsMgr_Node9,
+    &RtemsModelEventsMgr_Fixture9
+  );
+  // This runs RtemsModelEventsMgr_Fixture
+
+  T_log( T_NORMAL, "Test Fixture Pushed" );
+
+
+  ctx->send = send;
+  ctx->receive = receive;
+  ctx->get_pending_events = get_pending_events;
+  ctx->wait_class = wait_class;
+  ctx->waiting_for_event = waiting_for_event;
+
+  ctx->this_test_number = 9;
+
+  // RtemsModelEventsMgr_Prepare( ctx );
+  ctx->events_to_send = 0;
+  ctx->send_status = RTEMS_INCORRECT_STATE;
+  ctx->received_events = 0xffffffff;
+  ctx->receive_option_set = 0;
+  ctx->receive_timeout = RTEMS_NO_TIMEOUT;
+  ctx->unsatisfied_pending = 0xffffffff;
+  memset( &ctx->thread_switch_log, 0, sizeof( ctx->thread_switch_log ) );
+  T_eq_u32( GetPending( ctx ), 0 );
+  _Thread_Wait_flags_set( ctx->runner_thread, THREAD_WAIT_CLASS_PERIOD );
+
+  TestSegment0( ctx );
+
+  Runner( ctx );
+
+  RtemsModelEventsMgr_Cleanup( ctx );
+
+  T_log( T_NORMAL, "Run Pop Fixture" );
+  ShowWorkerSemaId( ctx );
+  T_pop_fixture();
+  ShowWorkerSemaId( ctx );
+}
+
+/** @} */
-- 
2.37.1 (Apple Git-137.1)

